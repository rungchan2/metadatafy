import type { NextConfig } from 'next';
import type { Compiler, WebpackPluginInstance } from 'webpack';
import * as path from 'path';
import * as fs from 'fs/promises';
import type { PluginConfig } from '../core/types';
import { ProjectAnalyzer } from '../core/analyzer';
import { createDefaultConfig, validateConfig } from '../core/config';
import { FileWriter } from '../core/output/file-writer';
import { ApiSender } from '../core/output/api-sender';
import { createProvider } from '../cli/database/provider';
import type { SupabaseConfig } from '../cli/database/types';

export interface NextPluginOptions extends Partial<PluginConfig> {
  /**
   * 분석 실행 시점
   * - 'build': 프로덕션 빌드 시에만 (기본값)
   * - 'dev': 개발 모드 시에만
   * - 'both': 둘 다
   */
  runOn?: 'build' | 'dev' | 'both';

  /**
   * Supabase 설정 (직접 전달)
   * 환경변수를 직접 전달할 때 사용
   *
   * @example
   * withMetadatafy({
   *   supabase: {
   *     url: process.env.SUPABASE_URL,
   *     serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,
   *     tableName: 'project_metadata',
   *   }
   * })
   */
  supabase?: {
    url: string;
    serviceRoleKey: string;
    tableName: string;
    fields?: {
      projectId?: string;
      metadata?: string;
      createdAt?: string;
      updatedAt?: string;
    };
  };
}

/**
 * 메타데이터 분석 실행 함수 (재사용)
 */
async function runMetadataAnalysis(
  pluginConfig: PluginConfig,
  rootDir: string,
  supabaseOptions?: NextPluginOptions['supabase']
): Promise<void> {
  const analyzer = new ProjectAnalyzer(pluginConfig);
  const fileWriter = new FileWriter(pluginConfig);
  const apiSender = pluginConfig.output.api?.enabled
    ? new ApiSender(pluginConfig)
    : null;

  if (pluginConfig.verbose) {
    console.log('[metadata-plugin] Starting analysis...');
  }

  const result = await analyzer.analyze(rootDir);

  // 파일 출력
  if (pluginConfig.output.file?.enabled) {
    const outputPath = path.resolve(rootDir, pluginConfig.output.file.path);
    await fileWriter.write(result, outputPath);

    if (pluginConfig.verbose) {
      console.log(`[metadata-plugin] Wrote metadata to ${outputPath}`);
    }
  }

  // API 전송
  if (apiSender) {
    await apiSender.send(result);

    if (pluginConfig.verbose) {
      console.log('[metadata-plugin] Sent metadata to API');
    }
  }

  // Supabase 업로드 (직접 전달된 경우)
  if (supabaseOptions?.url && supabaseOptions?.serviceRoleKey) {
    try {
      const supabaseConfig: SupabaseConfig = {
        provider: 'supabase',
        enabled: true,
        url: supabaseOptions.url,
        serviceRoleKey: supabaseOptions.serviceRoleKey,
        tableName: supabaseOptions.tableName,
        fields: {
          projectId: supabaseOptions.fields?.projectId || 'project_id',
          metadata: supabaseOptions.fields?.metadata || 'metadata',
          createdAt: supabaseOptions.fields?.createdAt || 'created_at',
          updatedAt: supabaseOptions.fields?.updatedAt || 'updated_at',
        },
      };

      const provider = await createProvider(supabaseConfig);
      const uploadResult = await provider.upload(result);

      if (pluginConfig.verbose) {
        if (uploadResult.success) {
          console.log(`[metadata-plugin] ${uploadResult.message} (Supabase)`);
        } else {
          console.log(`[metadata-plugin] Supabase upload failed: ${uploadResult.error}`);
        }
      }
    } catch (error) {
      console.error('[metadata-plugin] Supabase upload error:', error);
    }
  }
}

/**
 * Next.js 16+ Build Adapter 생성
 * Turbopack 환경에서도 동작하는 빌드 어댑터
 */
export function createMetadataAdapter(options: NextPluginOptions = {}) {
  const pluginConfig = createDefaultConfig(options);
  const supabaseOptions = options.supabase;

  // 설정 검증
  const errors = validateConfig(pluginConfig);
  if (errors.length > 0) {
    throw new Error(
      `[metadata-plugin] Invalid config:\n${errors.join('\n')}`
    );
  }

  return {
    name: 'metadata-adapter',

    async onBuildComplete({
      projectDir,
    }: {
      routes: unknown;
      outputs: unknown;
      projectDir: string;
      repoRoot: string;
      distDir: string;
      config: NextConfig;
      nextVersion: string;
    }) {
      if (pluginConfig.verbose) {
        console.log('[metadata-plugin] Build completed, running analysis...');
      }

      await runMetadataAnalysis(pluginConfig, projectDir, supabaseOptions);

      if (pluginConfig.verbose) {
        console.log('[metadata-plugin] Analysis completed');
      }
    },
  };
}

/**
 * Next.js 16+ 어댑터 파일 생성 헬퍼
 * Turbopack 지원을 위해 어댑터 파일을 자동 생성
 */
export async function generateAdapterFile(
  projectDir: string,
  options: NextPluginOptions = {}
): Promise<string> {
  const adapterPath = path.join(projectDir, '.metadata-adapter.js');

  const adapterContent = `
// Auto-generated by metadatafy
// This adapter enables metadata extraction with Turbopack (Next.js 16+)

const { createMetadataAdapter } = require('metadatafy/next');

module.exports = createMetadataAdapter(${JSON.stringify(options, null, 2)});
`;

  await fs.writeFile(adapterPath, adapterContent.trim());
  return adapterPath;
}

/**
 * Next.js 설정을 확장하는 함수
 * Next.js 16+ Turbopack: compiler.runAfterProductionCompile 사용
 * Next.js 15- Webpack: webpack 플러그인 사용 (폴백)
 */
export function withMetadata(
  options: NextPluginOptions = {}
): (nextConfig: NextConfig) => NextConfig {
  const pluginConfig = createDefaultConfig(options);
  const runOn = options.runOn || 'build';
  const supabaseOptions = options.supabase;

  // 설정 검증
  const errors = validateConfig(pluginConfig);
  if (errors.length > 0) {
    throw new Error(
      `[metadata-plugin] Invalid config:\n${errors.join('\n')}`
    );
  }

  // 중복 실행 방지 플래그
  let hasRunInCompiler = false;

  return (nextConfig: NextConfig): NextConfig => {
    // 기존 runAfterProductionCompile 훅 보존
    const existingRunAfterProductionCompile = (
      nextConfig as NextConfigWithCompiler
    ).compiler?.runAfterProductionCompile;

    return {
      ...nextConfig,

      // Next.js 16+ Turbopack 지원: compiler.runAfterProductionCompile
      compiler: {
        ...(nextConfig as NextConfigWithCompiler).compiler,

        async runAfterProductionCompile(metadata: {
          distDir: string;
          projectDir: string;
        }) {
          // 기존 훅 실행
          if (existingRunAfterProductionCompile) {
            await existingRunAfterProductionCompile(metadata);
          }

          // build 모드에서만 실행 (runOn 설정 확인)
          if (runOn !== 'build' && runOn !== 'both') {
            return;
          }

          hasRunInCompiler = true;

          if (pluginConfig.verbose) {
            console.log(
              '[metadata-plugin] runAfterProductionCompile triggered'
            );
          }

          await runMetadataAnalysis(pluginConfig, metadata.projectDir, supabaseOptions);

          if (pluginConfig.verbose) {
            console.log('[metadata-plugin] Analysis completed');
          }
        },
      },

      // Webpack 폴백 (Next.js 15 이하 또는 --webpack 플래그 사용 시)
      webpack(config, context) {
        const { dev, isServer } = context;

        // 서버 사이드에서만 실행 (클라이언트 빌드에서 중복 실행 방지)
        if (!isServer) {
          return typeof nextConfig.webpack === 'function'
            ? nextConfig.webpack(config, context)
            : config;
        }

        // runAfterProductionCompile에서 이미 실행했으면 스킵
        if (hasRunInCompiler) {
          return typeof nextConfig.webpack === 'function'
            ? nextConfig.webpack(config, context)
            : config;
        }

        const shouldRun =
          runOn === 'both' ||
          (runOn === 'build' && !dev) ||
          (runOn === 'dev' && dev);

        if (shouldRun) {
          config.plugins = config.plugins || [];
          config.plugins.push(new MetadataWebpackPlugin(pluginConfig, supabaseOptions));
        }

        // 기존 webpack 설정 체이닝
        if (typeof nextConfig.webpack === 'function') {
          return nextConfig.webpack(config, context);
        }

        return config;
      },
    };
  };
}

/**
 * Next.js config with compiler option (internal type)
 */
interface NextConfigWithCompiler extends NextConfig {
  compiler?: NextConfig['compiler'];
}

/**
 * Webpack 플러그인 클래스 (Webpack 모드용)
 */
class MetadataWebpackPlugin implements WebpackPluginInstance {
  private config: PluginConfig;
  private supabaseOptions?: NextPluginOptions['supabase'];
  private hasRun: boolean = false;

  constructor(config: PluginConfig, supabaseOptions?: NextPluginOptions['supabase']) {
    this.config = config;
    this.supabaseOptions = supabaseOptions;
  }

  apply(compiler: Compiler): void {
    const pluginName = 'MetadataWebpackPlugin';

    // 컴파일 시작 시 분석 실행
    compiler.hooks.beforeCompile.tapAsync(
      pluginName,
      async (_params, callback) => {
        // 중복 실행 방지
        if (this.hasRun) {
          return callback();
        }
        this.hasRun = true;

        try {
          await runMetadataAnalysis(this.config, compiler.context, this.supabaseOptions);
          callback();
        } catch (error) {
          callback(error as Error);
        }
      }
    );

    // 개발 모드에서 watch 재빌드 시 플래그 리셋
    compiler.hooks.watchRun.tap(pluginName, () => {
      // 필요시 재분석 로직 추가
    });
  }
}
